import{_,c as m,a as l,b as n,e as s,w as a,d as y,r as i,o as d}from"./app.fd297097.js";const ps=JSON.parse('{"title":"105. 从前序与中序遍历序列构造二叉树","description":"","frontmatter":{"title":"105. 从前序与中序遍历序列构造二叉树"},"headers":[{"level":3,"title":"递归","slug":"递归","link":"#递归","children":[]}],"relativePath":"algorithm/leetcode/construct-binary-tree-from-preorder-and-inorder-traversal.md","lastUpdated":1633780137000}'),D={name:"algorithm/leetcode/construct-binary-tree-from-preorder-and-inorder-traversal.md"},u=y("",10),h={class:"katex"},C={class:"katex-mathml"},A=y("",1),f=l("p",null,[l("strong",null,"复杂度分析")],-1),b={class:"katex"},g={class:"katex-mathml"},x=y("",1),T={class:"katex"},w={class:"katex-mathml"},k=l("span",{class:"katex-html","aria-hidden":"true"},[l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.43056em","vertical-align":"0em"}}),l("span",{class:"mord mathnormal"},"n")])],-1),v={class:"katex"},S={class:"katex-mathml"},M=y("",1),E={class:"katex"},B={class:"katex-mathml"},V=y("",1),O={class:"katex"},P={class:"katex-mathml"},I=y("",1),N={class:"katex"},L={class:"katex-mathml"},R=y("",1),z={class:"katex"},$={class:"katex-mathml"},J=l("span",{class:"katex-html","aria-hidden":"true"},[l("span",{class:"base"},[l("span",{class:"strut",style:{height:"0.69444em","vertical-align":"0em"}}),l("span",{class:"mord mathnormal"},"h")])],-1),U={class:"katex"},j={class:"katex-mathml"},q=y("",1),G={class:"katex"},H={class:"katex-mathml"},K=y("",1),Q=y("",1);function W(X,Y,Z,ss,as,ns){const p=i("mi"),e=i("mo"),F=i("mn"),t=i("mrow"),o=i("annotation"),r=i("semantics"),c=i("math");return d(),m("div",null,[u,l("p",null,[n("在中序遍历中对根节点进行定位时，一种简单的方法是直接扫描整个中序遍历的结果并找出根节点，但这样做的时间复杂度较高。我们可以考虑使用哈希表来帮助我们快速地定位根节点。对于哈希映射中的每个键值对，键表示一个元素（节点的值），值表示其在中序遍历中的出现位置。在构造二叉树的过程之前，我们可以对中序遍历的列表进行一遍扫描，就可以构造出这个哈希映射。在此后构造二叉树的过程中，我们就只需要 "),l("span",h,[l("span",C,[s(c,{xmlns:"http://www.w3.org/1998/Math/MathML"},{default:a(()=>[s(r,null,{default:a(()=>[s(t,null,{default:a(()=>[s(p,null,{default:a(()=>[n("O")]),_:1}),s(e,{stretchy:"false"},{default:a(()=>[n("(")]),_:1}),s(F,null,{default:a(()=>[n("1")]),_:1}),s(e,{stretchy:"false"},{default:a(()=>[n(")")]),_:1})]),_:1}),s(o,{encoding:"application/x-tex"},{default:a(()=>[n("O(1)")]),_:1})]),_:1})]),_:1})]),A]),n(" 的时间对根节点进行定位了。")]),f,l("ul",null,[l("li",null,[l("p",null,[n("时间复杂度："),l("span",b,[l("span",g,[s(c,{xmlns:"http://www.w3.org/1998/Math/MathML"},{default:a(()=>[s(r,null,{default:a(()=>[s(t,null,{default:a(()=>[s(p,null,{default:a(()=>[n("O")]),_:1}),s(e,{stretchy:"false"},{default:a(()=>[n("(")]),_:1}),s(p,null,{default:a(()=>[n("n")]),_:1}),s(e,{stretchy:"false"},{default:a(()=>[n(")")]),_:1})]),_:1}),s(o,{encoding:"application/x-tex"},{default:a(()=>[n("O(n)")]),_:1})]),_:1})]),_:1})]),x]),n("，其中 "),l("span",T,[l("span",w,[s(c,{xmlns:"http://www.w3.org/1998/Math/MathML"},{default:a(()=>[s(r,null,{default:a(()=>[s(t,null,{default:a(()=>[s(p,null,{default:a(()=>[n("n")]),_:1})]),_:1}),s(o,{encoding:"application/x-tex"},{default:a(()=>[n("n")]),_:1})]),_:1})]),_:1})]),k]),n(" 是树中的节点个数。")])]),l("li",null,[l("p",null,[n("空间复杂度："),l("span",v,[l("span",S,[s(c,{xmlns:"http://www.w3.org/1998/Math/MathML"},{default:a(()=>[s(r,null,{default:a(()=>[s(t,null,{default:a(()=>[s(p,null,{default:a(()=>[n("O")]),_:1}),s(e,{stretchy:"false"},{default:a(()=>[n("(")]),_:1}),s(p,null,{default:a(()=>[n("n")]),_:1}),s(e,{stretchy:"false"},{default:a(()=>[n(")")]),_:1})]),_:1}),s(o,{encoding:"application/x-tex"},{default:a(()=>[n("O(n)")]),_:1})]),_:1})]),_:1})]),M]),n("，除去返回的答案需要的 "),l("span",E,[l("span",B,[s(c,{xmlns:"http://www.w3.org/1998/Math/MathML"},{default:a(()=>[s(r,null,{default:a(()=>[s(t,null,{default:a(()=>[s(p,null,{default:a(()=>[n("O")]),_:1}),s(e,{stretchy:"false"},{default:a(()=>[n("(")]),_:1}),s(p,null,{default:a(()=>[n("n")]),_:1}),s(e,{stretchy:"false"},{default:a(()=>[n(")")]),_:1})]),_:1}),s(o,{encoding:"application/x-tex"},{default:a(()=>[n("O(n)")]),_:1})]),_:1})]),_:1})]),V]),n(" 空间之外，我们还需要使用 "),l("span",O,[l("span",P,[s(c,{xmlns:"http://www.w3.org/1998/Math/MathML"},{default:a(()=>[s(r,null,{default:a(()=>[s(t,null,{default:a(()=>[s(p,null,{default:a(()=>[n("O")]),_:1}),s(e,{stretchy:"false"},{default:a(()=>[n("(")]),_:1}),s(p,null,{default:a(()=>[n("n")]),_:1}),s(e,{stretchy:"false"},{default:a(()=>[n(")")]),_:1})]),_:1}),s(o,{encoding:"application/x-tex"},{default:a(()=>[n("O(n)")]),_:1})]),_:1})]),_:1})]),I]),n(" 的空间存储哈希映射，以及 "),l("span",N,[l("span",L,[s(c,{xmlns:"http://www.w3.org/1998/Math/MathML"},{default:a(()=>[s(r,null,{default:a(()=>[s(t,null,{default:a(()=>[s(p,null,{default:a(()=>[n("O")]),_:1}),s(e,{stretchy:"false"},{default:a(()=>[n("(")]),_:1}),s(p,null,{default:a(()=>[n("h")]),_:1}),s(e,{stretchy:"false"},{default:a(()=>[n(")")]),_:1})]),_:1}),s(o,{encoding:"application/x-tex"},{default:a(()=>[n("O(h)")]),_:1})]),_:1})]),_:1})]),R]),n("（其中 "),l("span",z,[l("span",$,[s(c,{xmlns:"http://www.w3.org/1998/Math/MathML"},{default:a(()=>[s(r,null,{default:a(()=>[s(t,null,{default:a(()=>[s(p,null,{default:a(()=>[n("h")]),_:1})]),_:1}),s(o,{encoding:"application/x-tex"},{default:a(()=>[n("h")]),_:1})]),_:1})]),_:1})]),J]),n(" 是树的高度）的空间表示递归时栈空间。这里 "),l("span",U,[l("span",j,[s(c,{xmlns:"http://www.w3.org/1998/Math/MathML"},{default:a(()=>[s(r,null,{default:a(()=>[s(t,null,{default:a(()=>[s(p,null,{default:a(()=>[n("h")]),_:1}),s(e,null,{default:a(()=>[n("<")]),_:1}),s(p,null,{default:a(()=>[n("n")]),_:1})]),_:1}),s(o,{encoding:"application/x-tex"},{default:a(()=>[n("h < n")]),_:1})]),_:1})]),_:1})]),q]),n("，所以总空间复杂度为 "),l("span",G,[l("span",H,[s(c,{xmlns:"http://www.w3.org/1998/Math/MathML"},{default:a(()=>[s(r,null,{default:a(()=>[s(t,null,{default:a(()=>[s(p,null,{default:a(()=>[n("O")]),_:1}),s(e,{stretchy:"false"},{default:a(()=>[n("(")]),_:1}),s(p,null,{default:a(()=>[n("n")]),_:1}),s(e,{stretchy:"false"},{default:a(()=>[n(")")]),_:1})]),_:1}),s(o,{encoding:"application/x-tex"},{default:a(()=>[n("O(n)")]),_:1})]),_:1})]),_:1})]),K]),n("。")])])]),Q])}const es=_(D,[["render",W]]);export{ps as __pageData,es as default};
