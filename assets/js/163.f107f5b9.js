(window.webpackJsonp=window.webpackJsonp||[]).push([[163],{366:function(_,v,t){"use strict";t.r(v);var a=t(0),r=Object(a.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"整体流程图"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#整体流程图"}},[_._v("#")]),_._v(" 整体流程图")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://shimo.zhenguanyu.com/uploader/proxy?url=https%3A%2F%2Fcos.ap-beijing.myqcloud.com%2Fyfd-shimo-images-1253271207%2FWoaphqYQBI8IQfYa%2FWeb_Recorder_%25E6%258A%2580%25E6%259C%25AF%25E8%25B0%2583%25E7%25A0%2594%25E6%2596%25B9%25E6%25A1%2588-%25E6%25B5%2581%25E7%25A8%258B%25E5%259B%25BE-v0.2.001.jpeg&fileGuid=vXRyT3HpxX3VThk3",alt:"图片"}})]),_._v(" "),t("h1",{attrs:{id:"part-0-项目与-sdk-建设"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#part-0-项目与-sdk-建设"}},[_._v("#")]),_._v(" Part 0. 项目与 SDK 建设")]),_._v(" "),t("h2",{attrs:{id:"_0-1-研发框架"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_0-1-研发框架"}},[_._v("#")]),_._v(" 0.1 研发框架")]),_._v(" "),t("p",[_._v("数据收集侧：不依赖具体 UI / 应用框架，采用  Vanilla JavaScript 实现收集侧主流程。")]),_._v(" "),t("p",[_._v("数据回放侧：TBD")]),_._v(" "),t("h2",{attrs:{id:"_0-2-数据收集方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_0-2-数据收集方案"}},[_._v("#")]),_._v(" 0.2 数据收集方案")]),_._v(" "),t("p",[_._v("本地数据栈存储"),t("strong",[_._v("采用 IndexedDB")])]),_._v(" "),t("p",[_._v("上报策略")]),_._v(" "),t("ul",[t("li",[_._v("本地拼装与存储：本地需上报的数据按照先进先出原则储存在本地 IndexedDB 用于待上报")]),_._v(" "),t("li",[_._v("定时上报/重试：上报完成（OSS request 返回 "),t("code",[_._v("200")]),_._v(" 状态）从 IndexedDB 中删除对应数据；设定本地上报重试阈值，阈值范围内可以重复上报防止网络原因、OSS 服务原因或者用户终止等原因导致的数据上报中断/失败")]),_._v(" "),t("li",[_._v("本地存储更新：待上报数据完成收集、上报完成/失败/重试等状态下更新本地存储队列")])]),_._v(" "),t("p",[_._v("实际执行时还需要考虑")]),_._v(" "),t("ul",[t("li",[_._v("上报重试的阈值应该有阶梯式调整")]),_._v(" "),t("li",[_._v("需要定义失败数据，以辅助更新/清理本地待上报数据队列")]),_._v(" "),t("li",[_._v("数据应按照基本分片单位进行连续性上报，以保证顺序")]),_._v(" "),t("li",[_._v("本地数据积压需要考虑特殊处理流程")]),_._v(" "),t("li",[_._v("本地暂存数据需要考虑时效性")]),_._v(" "),t("li",[_._v("本地暂存数据需要设计触发上报请求的频率")])]),_._v(" "),t("h2",{attrs:{id:"_0-3-数据拦截方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_0-3-数据拦截方案"}},[_._v("#")]),_._v(" 0.3 数据拦截方案")]),_._v(" "),t("p",[_._v("fetch 是 ajax 的一种，HttpClient、axios 这类库底层可能是 XHR 也可能是 fetch，其他场景还有 WebSocket 等，所以需要一个更普适的拦截策略。")]),_._v(" "),t("p",[_._v("采用 "),t("code",[_._v("Service Worker")]),_._v(" 作为数据拦截方案，拦截内部再对不同类型的请求进行分发（例如 fetch、XHR 等），在拦截的控制粒度上需要进一步调研。")]),_._v(" "),t("h2",{attrs:{id:"_0-4-备忘"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_0-4-备忘"}},[_._v("#")]),_._v(" 0.4 备忘")]),_._v(" "),t("p",[_._v("就不包含 fetch 的 ajax 拦截方案而言，现有很成熟的方案可以去做这一块，可以参考"),t("a",{attrs:{href:"https://github.com/wendux/Ajax-hook",target:"_blank",rel:"noopener noreferrer"}},[_._v("https://github.com/wendux/Ajax-hook"),t("OutboundLink")],1)]),_._v(" "),t("h1",{attrs:{id:"part-1-数据收集"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#part-1-数据收集"}},[_._v("#")]),_._v(" Part 1. 数据收集")]),_._v(" "),t("p",[_._v("约定")]),_._v(" "),t("ul",[t("li",[_._v("需要考虑 har 类数据上报，其中前端构建产物不用在用户侧进行上报，其他数据类型包含用户操作数据以及接口请求数据")]),_._v(" "),t("li",[_._v("需要确保用户操作与数据的时序，同时可以考虑计时校准")])]),_._v(" "),t("h2",{attrs:{id:"_1-1-方案概述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-方案概述"}},[_._v("#")]),_._v(" 1.1 方案概述")]),_._v(" "),t("p",[_._v("方案描述：收集两类数据，一类是对 HAR 类数据进行收集，包含接口数据以及前端构建产物；一类是用户操作数据，包含用户的行为、触发的操作以及关联的数据请求等。\n两类数据在数据清洗后入库存储，而后在数据回放侧构建沙箱进行页面回放。")]),_._v(" "),t("h2",{attrs:{id:"_1-2-用户片段与分片定义"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-用户片段与分片定义"}},[_._v("#")]),_._v(" 1.2 用户片段与分片定义")]),_._v(" "),t("p",[_._v("在不确定“快进“到底如何实现的前提下不好确定”片段“这个概念和快进的关系。")]),_._v(" "),t("p",[_._v("片段定义为最小可播放的单位，它等价于一次用户操作（事件）或一个 HTTP 响应。把我们的应用程序（业务项目如 Focus、Cyber）看作一个状态机，则每次用户操作和 HTTP 响应都使得状态机从某个状态流转到另一个状态，状态按顺序不断流转就是“播放”。")]),_._v(" "),t("p",[_._v("采取上述定义，分片的定义如下：分片无固定大小，我们期望一个分片的大小在某个合理的范围内即可。一个分片可以"),t("strong",[_._v("恰好包含")]),_._v("N 个片段（的完整数据），也可以由若干个连续分片"),t("strong",[_._v("恰好组成")]),_._v("一个片段。在这种划分方式下，给定第 0 ~ x 个连续的分片，它在播放器中大概率可以播放（因为片段的边界和分片的边界大量重合）。")]),_._v(" "),t("p",[_._v("分片包含一些信息（分片内各小片段长度、本分片是一个大片段的第 N 个分片）方便服务端清洗得到单个的片段，后续播放环节只关心片段这种数据结构。")]),_._v(" "),t("p",[_._v("另一个想法是分片只要包含恰当的信息如数据结构分界点，即使边界与片段的边界不重合，服务端也能方便地清洗出片段，只不过如果同样给定 x 个连续分片，前面的方案大概率能多播放一个片段。")]),_._v(" "),t("p",[_._v("如果用户一段时间内不操作则不会收集到数据（不考虑轮询的情况下），也就不会产生片段和分片。")]),_._v(" "),t("p",[_._v("其他考虑事项：")]),_._v(" "),t("ul",[t("li",[_._v("片段的命名 - 包含事件及数据的单位数据")]),_._v(" "),t("li",[_._v("未来计划，可以考虑在分片上扩展 meta 信息附带上报")]),_._v(" "),t("li",[_._v("上报内容是否需要过滤，如只针对类似 error 信息进行部分收集，否则全量数据可能过大")]),_._v(" "),t("li",[_._v("上报数据的完整性校验是通过文件命名执行，还是读取文件内容执行")])]),_._v(" "),t("h2",{attrs:{id:"_1-3-应用状态数据收集"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-应用状态数据收集"}},[_._v("#")]),_._v(" 1.3 应用状态数据收集")]),_._v(" "),t("h2",{attrs:{id:"_1-4-har-类数据收集"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-har-类数据收集"}},[_._v("#")]),_._v(" 1.4 HAR 类数据收集")]),_._v(" "),t("p",[_._v("参考："),t("a",{attrs:{href:"https://w3c.github.io/web-performance/specs/HAR/Overview.html",target:"_blank",rel:"noopener noreferrer"}},[_._v("https://w3c.github.io/web-performance/specs/HAR/Overview.html"),t("OutboundLink")],1)]),_._v(" "),t("p",[_._v("文件共846 行， 一个 har 文件可以存多个请求， 其中 har 文件相关的meta 信息有 version， creator，pages 等，不到 20 行。"),t("br"),_._v("\n多个请求存于 entries 下，已上面例子看，一个请求有 800 行， 其中，_initiator 比较大，约 600 行。其他较大的 为 request 和 response")]),_._v(" "),t("p",[_._v("此外还需考虑上报页面初始化时的 cookie 及本地存储数据。")]),_._v(" "),t("p",[_._v("上面所列 HAR 中部分字段是否能收集（例如 _initiator）到以及如何收集需要安排技术调研。")]),_._v(" "),t("p",[_._v("关于快照：类似 rrweb 的 DOM 重现，能够保底获得「录屏」数据，某种程度上也能够作为 debug 参考。\n另外，可以用于排查在实际使用场景中确认有多少比例的场景是只需要录屏就能解决 bug 的。如何实施、收集需要详细设计，低优先级。")]),_._v(" "),t("p",[_._v("关于 traceId：用途为标记操作/数据，供数据清洗使用")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://shimo.zhenguanyu.com/uploader/proxy?url=https%3A%2F%2Fcos.ap-beijing.myqcloud.com%2Fyfd-shimo-images-1253271207%2Fbjvm7e5AjNMYQiY4%2Fimage.png&fileGuid=vXRyT3HpxX3VThk3",alt:"图片"}})]),_._v(" "),t("p",[_._v("一个点击操作触发了 DOM 变更，新 DOM 里初始化会有一堆新请求，这些请求如何建立归属？在采用事件驱动的数据收集方案基础上，可以认为「两个动作之间的请求都属于上一个动作」，以此建立关联。")]),_._v(" "),t("p",[_._v("实际执行时需仔细考虑 traceId 该如何生成，以确保数据在顺序上的唯一性；另外，短时间内多个请求发出可能产生的乱序问题，需要有容错处理假设。\n例如，加入请求间隔很近，可以假设他们就是按照固定顺序进行，不存在可能的随机顺序错乱问题。")]),_._v(" "),t("h2",{attrs:{id:"_1-5-用户操作数据收集"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-5-用户操作数据收集"}},[_._v("#")]),_._v(" 1.5 用户操作数据收集")]),_._v(" "),t("p",[_._v("依据用户片段与分片的定义进行收集，同时包含与 HAR 数据的关联（traceId）。")]),_._v(" "),t("h2",{attrs:{id:"_1-6-特殊类型数据收集"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-6-特殊类型数据收集"}},[_._v("#")]),_._v(" 1.6 特殊类型数据收集")]),_._v(" "),t("p",[_._v("类似 OSS 的数据资源（某些场景下，例如 H5 编辑器），无法模拟网络的话，在这类业务场景下，需要把某些网络请求看作跟数据接口请求等价，需要被收集；回放时的处理是一致的。")]),_._v(" "),t("p",[_._v("针对具体业务场景分析：编辑器中对 JSON 数据的 GET 请求较少、PUT 较多，PUT 请求体可以考虑忽略内容，保证 Response 一致即可，而 Response 体积较小，这样总体数据量不算大，正常收集即可。")]),_._v(" "),t("h2",{attrs:{id:"_1-7-注意点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-7-注意点"}},[_._v("#")]),_._v(" 1.7 注意点")]),_._v(" "),t("ul",[t("li",[_._v("Web API 限制需要调用 devtools API 才能存储 har 数据，一般为 chrome 插件实现方案，由于前提之一即用户均为不懂技术的辅导老师，故实际实现需考虑收集形式与方案（非 chrome 插件形式）")]),_._v(" "),t("li",[_._v("序列化与快照有较为成熟的社区实现")]),_._v(" "),t("li",[_._v("Service Worker 维护的是 url -> response 的映射，服务端接口返回结果会随时间变化，那么需要保证用户操作序列中每个 request 的唯一性；这个唯一性由 traceId 定义（可以包含时间戳等信息），需单独设计以完成 traceId 到单次用户操作的映射关系。这种方案的前提是所需回放资源已一次性拉取至本地（或在播放前拉取足够的安全量资源，后续资源可以空闲调度持续下载）。")]),_._v(" "),t("li",[_._v("用于收集数据上报的计算，不能在主线程操作，否则很影响交互体验，涉及到 BOM/DOM 的相关数据可以直接事件传递通知或者 SharedArrayBuffer 共享，其余可以直接在 Web Worker 里初始化/处理")]),_._v(" "),t("li",[_._v("利用 requestIdleCallback API 与本地存储类 API，保证数据上报不对用户交互造成影响，并保证数据上报的完整性（防止传输中断或未上报数据丢失）")]),_._v(" "),t("li",[_._v("为了确保构建产物和用户资源等价，针对每次构建应拉取 hash 等信息计算 md5 用于校验，投入研发时再做细节考虑。")])]),_._v(" "),t("h1",{attrs:{id:"part-2-数据清洗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#part-2-数据清洗"}},[_._v("#")]),_._v(" Part 2. 数据清洗")]),_._v(" "),t("h2",{attrs:{id:"_2-1-整体流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-整体流程"}},[_._v("#")]),_._v(" 2.1 整体流程")]),_._v(" "),t("p",[_._v("数据清洗与存储整体流程如下所示")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://shimo.zhenguanyu.com/uploader/proxy?url=https%3A%2F%2Fcos.ap-beijing.myqcloud.com%2Fyfd-shimo-images-1253271207%2F0E1rrw1itEIHlVxp%2Fimage.png&fileGuid=vXRyT3HpxX3VThk3",alt:"图片"}})]),_._v(" "),t("h2",{attrs:{id:"_2-2-数据合并与校验"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-数据合并与校验"}},[_._v("#")]),_._v(" 2.2 数据合并与校验")]),_._v(" "),t("p",[_._v("前端切片时应该附上当前片段唯一 ID + 所属分片（如果需要做进一步拆分上报） + 当前片段序号 + 总计片段数量（用于服务端校验当前片段是否上报完成可以进入合并清洗环节）。")]),_._v(" "),t("p",[_._v("示意图如下：")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://shimo.zhenguanyu.com/uploader/proxy?url=https%3A%2F%2Fcos.ap-beijing.myqcloud.com%2Fyfd-shimo-images-1253271207%2FBbZJm1oKTo8XuAEa%2Fimage.png&fileGuid=vXRyT3HpxX3VThk3",alt:"图片"}})]),_._v(" "),t("p",[_._v("说明")]),_._v(" "),t("ol",[t("li",[_._v("按照「用户片段」为基本单位进行服务端清洗、合并、校验处理")]),_._v(" "),t("li",[_._v("服务端在每收到一份前端分片的上报数据后，校验当前数据所属分片数据总量是否已经上报完全，完全后才进行合并和清洗操作")]),_._v(" "),t("li",[_._v("用户侧在上报完成时同样通知服务端，与说明2结合一起保障触发下一步流程")]),_._v(" "),t("li",[_._v("前端每份上报的数据中所包含信息应该都能确定当前数据所属片段是否完整、所属片段是否上传完毕、等信息")])]),_._v(" "),t("h2",{attrs:{id:"_2-3数据清洗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-3数据清洗"}},[_._v("#")]),_._v(" 2.3数据清洗")]),_._v(" "),t("p",[_._v("需要根据回放策略指定清洗方案，需在进入研发阶段后再详细设计")]),_._v(" "),t("ul",[t("li",[_._v("合并后冗余字段删除")]),_._v(" "),t("li",[_._v("回放操作按时间戳校准顺序")]),_._v(" "),t("li",[_._v("组合回放所需的构建产物与环境数据等")])]),_._v(" "),t("h1",{attrs:{id:"part-3-数据存储"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#part-3-数据存储"}},[_._v("#")]),_._v(" Part 3. 数据存储")]),_._v(" "),t("p",[_._v("HAR 类上报清洗完成的资源数据也存入 OSS，表内只维护 CDN 地址与操作等信息的映射对照关系。")]),_._v(" "),t("p",[_._v("其余存储细节依据实际清洗方案再进一步制定。")]),_._v(" "),t("h1",{attrs:{id:"part-4-数据回放"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#part-4-数据回放"}},[_._v("#")]),_._v(" Part 4. 数据回放")]),_._v(" "),t("h2",{attrs:{id:"_4-1-接口方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-接口方案"}},[_._v("#")]),_._v(" 4.1 接口方案")]),_._v(" "),t("p",[_._v("接口层不做复杂逻辑，由前端计算好所需资源 key 值等信息，服务端从 OSS 提取对应内容转发给前端进行回放。")]),_._v(" "),t("h2",{attrs:{id:"_4-2-容器方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-容器方案"}},[_._v("#")]),_._v(" 4.2 容器方案")]),_._v(" "),t("p",[_._v("容器方案采用 iframe 进行建设。")]),_._v(" "),t("h3",{attrs:{id:"_4-2-1关于形式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-1关于形式"}},[_._v("#")]),_._v(" 4.2.1关于形式")]),_._v(" "),t("p",[_._v("iframe 可以在普通网页中也可以在 Chrome 插件的网页中。调研发现 ServiceWorker 能拦截 JS 发起的 AJAX 请求和非 JS 代码发起的静态资源请求，满足我们的需求。即使后期发现某些功能需要借助 Chrome API，迁移到插件里成本也不高。所以先不考虑 Chrome 插件的形式。")]),_._v(" "),t("h3",{attrs:{id:"_4-2-2-关于跨域"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-2-关于跨域"}},[_._v("#")]),_._v(" 4.2.2 关于跨域")]),_._v(" "),t("p",[_._v("已有开源方案以及调研过的产品中，iframe 嵌套方案为主要实现方案。在回放中主要需要关注两方面信息，一是用户操作轨迹展示，二是用户操作回放。")]),_._v(" "),t("p",[_._v("前者可以通过一个 canvas 透明蒙层绘制实现，后者为回放的主要考虑部分。iframe 的主要限制在于针对安全性做了 sandbox 以及 allow 的一些控制，在我们的使用场景中，由于内容是自助可控的前端构建产物以及截取的接口数据，故我们可以最大限度的放开 iframe 的沙箱限制。")]),_._v(" "),t("p",[_._v("主要考虑点在可能存在的跨域问题上。")]),_._v(" "),t("p",[_._v("在使用 iframe 作为回放方案的前提下，跨域问题主要可能涵盖三个方面：")]),_._v(" "),t("ul",[t("li",[_._v("网络请求")]),_._v(" "),t("li",[_._v("DOM 操控")]),_._v(" "),t("li",[_._v("cookie、本地存储、IndexedDB 等内容共享")])]),_._v(" "),t("p",[_._v("以上问题如果在同一一级域名下处理是有解法的，除此外通过 postMessage 通信能解决大部分跨域数据传输问题，因此就回放操作而言，一个经过配置 sandbox 与 allow 等信息的 iframe 对我们推进回放实现可能并不会有限制。")]),_._v(" "),t("p",[_._v("具体到除以上提及的解决跨域问题方法外，我们其实也并不用关心 iframe 跨域的具体问题。回放其实是本地的调试行为，因此我们甚至可以（激进地）完全放弃 chrome 的同源策略：可以通过启动 chrome 时带上参数来关闭它；也可以为了安全性使用现成的"),t("a",{attrs:{href:"https://chrome.google.com/webstore/detail/allow-cors-access-control/lhobafahddgcelffkeicbaginigeejlf?hl=en",target:"_blank",rel:"noopener noreferrer"}},[_._v("chrome 跨域插件"),t("OutboundLink")],1),_._v("，手动构造出项目相关的域名模式，添加到插件的可跨域白名单。")]),_._v(" "),t("h2",{attrs:{id:"_4-4-播放方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-播放方案"}},[_._v("#")]),_._v(" 4.4 播放方案")]),_._v(" "),t("p",[_._v("播放方案前提约定：")]),_._v(" "),t("ol",[t("li",[_._v("**假设1：把用户侧收集的一段数据在播放器中播放时必然产生与用户侧相同的效果：**比如用户侧点击了某个按钮 1s 后弹出了弹窗，在播放器中重放该点击事件 1s 后该弹窗必然存在。理论上存在播放器的响应比用户侧当时的响应要慢（或快）、导致后续状态不对的可能性，但对于这种情况也没有好的解决方法。")]),_._v(" "),t("li",[t("strong",[_._v("假设2：用户回放侧的设备、网络等性能表现必然好于用户收集侧")]),_._v("：在回放侧 dispatch event 时候需要保证 DOM 行为在时序上的准确性，由于涉及到 DOM 变更的实现时间无法保证，因此按此方案实现的回放只在此前提下才能达到准确回放效果")]),_._v(" "),t("li",[t("strong",[_._v("假设3：存在一些场景下，在当前 event 过程结束前不允许 dispatch 下一个 event，该类型 event 需定义")]),_._v("：勇伦给的例子很好的解释了这种情况，“这个操作本来在用户那里花了3s，用户2s时点了别的一个按钮，3s时弹出弹框；那我们播放器可能1s就把操作执行完了，2s时dispatch click事件点的地方就跟用户点的不是同一个了”。思想同1，有部分出入。")]),_._v(" "),t("li",[t("strong",[_._v("假设4：存在一些允许快进的回放场景，当且仅当该场景用户无操作且轮询与 WebSocket 推送对应用状态不造成变更影响")]),_._v("：例如定时轮询版本与触发保存操作，例如 ws 通信监听+1通知等信息推送，在无状态变更的情况，可以将这些请求数据的响应认为是未改变应用状态。")])]),_._v(" "),t("p",[_._v("示意图如下")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://shimo.zhenguanyu.com/uploader/proxy?url=https%3A%2F%2Fcos.ap-beijing.myqcloud.com%2Fyfd-shimo-images-1253271207%2FPMK8uIo7UWMNlyWm%2FWeb_Recorder_%25E6%258A%2580%25E6%259C%25AF%25E8%25B0%2583%25E7%25A0%2594%25E6%2596%25B9%25E6%25A1%2588.001.jpeg&fileGuid=vXRyT3HpxX3VThk3",alt:"图片"}})]),_._v(" "),t("h3",{attrs:{id:"_4-4-1-播放职责范围"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-1-播放职责范围"}},[_._v("#")]),_._v(" 4.4.1 播放职责范围")]),_._v(" "),t("ol",[t("li",[_._v("构建前端站点的运行环境\n"),t("ol",[t("li",[_._v("获取页面 HTML 并运行（由 HTML 驱动 JS 加载并执行）")])])]),_._v(" "),t("li",[_._v("回放用户操作\n"),t("ol",[t("li",[_._v("期望能模拟用户的操作，而不是回放 DOM 的变化（用 dispatchEvent 或 puppeteer 的操作 API 实现）")]),_._v(" "),t("li",[_._v("用户操作提示层（轨迹、UI 标注或者文字展示等）")])])]),_._v(" "),t("li",[_._v("回放数据\n"),t("ol",[t("li",[_._v("拦截用户请求")]),_._v(" "),t("li",[_._v("时间积累误差修复，与数据校正")])])])]),_._v(" "),t("p",[_._v("播放侧实现应包含以下几个部分：")]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("播放控制层")]),_._v("，包含暂停、播放等 UI 层控制组件，如果采用插件形式实现也可以包含插件开关以及其他选项按钮等")]),_._v(" "),t("li",[t("strong",[_._v("播放容器页")]),_._v("，应作为播放侧的根结点，包含播放控制组件以及用户轨迹绘制层画布，以及播放落地页，完成落地页到控件的通信、数据传输以及展示控制等功能")]),_._v(" "),t("li",[t("strong",[_._v("播放落地页")]),_._v("，包含实际需要回放的页面、数据，对外暴露至上层的数据传输接口，对内实现数据更新后匹配上用户操作片段的 DOM 变更")])]),_._v(" "),t("p",[_._v("注：轨迹绘制层目的是为了在回放时提示用户涉及的操作，表现形式可变，例如以下几种情况在目的上等价：")]),_._v(" "),t("ol",[t("li",[_._v("用户鼠标轨迹展示")]),_._v(" "),t("li",[_._v("用户 click / input 等事件 UI 提示")]),_._v(" "),t("li",[_._v("文字列表列出用户的鼠标操作")])]),_._v(" "),t("h3",{attrs:{id:"_4-4-2-关于快进功能"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-2-关于快进功能"}},[_._v("#")]),_._v(" 4.4.2 关于快进功能")]),_._v(" "),t("p",[_._v("定义安全快进的时间窗口，以解决空等时间为前提目的。")]),_._v(" "),t("p",[_._v("“安全”应该理解为对应用状态没有作出改变的状态片段，除了定时轮询外，还会有 websocket 消息推送，这几类数据如果只是拿到数据但对应用状态没有做变更，应该都可以安全跳过；另外，时间的定义可以是简单拍一个认为上下状态无关的时间窗口，例如认为上一个有效操作结束5分钟后到下一个有效操作开始之间的这段时间，可以安全跳过，也可以更细的定义。")]),_._v(" "),t("p",[_._v("关于可快进分片的具体细节，在方案执行时还需考虑")]),_._v(" "),t("ul",[t("li",[_._v("每个分片是否允许一个时间波动延时")]),_._v(" "),t("li",[_._v("需要有可定义的方法用来判断分片本身是否涉及应用状态变更")])]),_._v(" "),t("p",[_._v("考虑到快进策略可能并非普适且完美，需在 SDK 建设上提供供业务方可选的配置开关。")]),_._v(" "),t("p",[_._v("快进的进一步利用")]),_._v(" "),t("ul",[t("li",[_._v("如果能够快进到目标状态，如何保存目标状态？\n"),t("ul",[t("li",[_._v("dump chrome内存？")])])]),_._v(" "),t("li",[_._v("如何在目标状态前后进行操作、进行debug？")])]),_._v(" "),t("p",[_._v("除快进外，还应考虑全局可跳过机制，例如当用户点击链接切换至另一个路由页面时。")]),_._v(" "),t("h1",{attrs:{id:"参考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[_._v("#")]),_._v(" 参考")]),_._v(" "),t("ul",[t("li",[_._v("rrweb 准确计时匹配实现"),t("a",{attrs:{href:"https://github.com/rrweb-io/rrweb/blob/9b8c7f755fb59ff91f568ee41ebcc6d060ef8458/src/replay/timer.ts",target:"_blank",rel:"noopener noreferrer"}},[_._v("https://github.com/rrweb-io/rrweb/blob/9b8c7f755fb59ff91f568ee41ebcc6d060ef8458/src/replay/timer.ts"),t("OutboundLink")],1)])])])}),[],!1,null,null,null);v.default=r.exports}}]);