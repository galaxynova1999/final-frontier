(window.webpackJsonp=window.webpackJsonp||[]).push([[154],{356:function(t,s,a){"use strict";a.r(s);var n=a(0),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("原文链接")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://v8.dev/features/atomics",target:"_blank",rel:"noopener noreferrer"}},[t._v("v8.dev"),a("OutboundLink")],1)])]),t._v(" "),a("p"),a("div",{staticClass:"table-of-contents"},[a("ul",[a("li",[a("a",{attrs:{href:"#atomics-api介绍"}},[t._v("Atomics API介绍")])]),a("li",[a("a",{attrs:{href:"#实现一个互斥锁"}},[t._v("实现一个互斥锁")])]),a("li",[a("a",{attrs:{href:"#同步上锁和解锁"}},[t._v("同步上锁和解锁")])]),a("li",[a("a",{attrs:{href:"#异步上锁"}},[t._v("异步上锁")])])])]),a("p"),t._v(" "),a("h3",{attrs:{id:"atomics-api介绍"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#atomics-api介绍"}},[t._v("#")]),t._v(" Atomics API介绍")]),t._v(" "),a("p",[a("code",[t._v("Atomics.wait")]),t._v(" 和 "),a("code",[t._v("Atomics.notify")]),t._v(" 是两个很有用的低层级("),a("code",[t._v("low-level")]),t._v(")的同步原语("),a("code",[t._v("synchronization primitives")]),t._v(")，可以用来实现互斥锁("),a("code",[t._v("mutex")]),t._v(")和其他方式的同步。\n值得注意的是， "),a("code",[t._v("Atomics.wait")]),t._v("是会产生阻塞的，所以就不能在主线程上调用该方法（强行使用会抛出"),a("code",[t._v("TypeError")]),t._v("）。")]),t._v(" "),a("p",[t._v("从"),a("code",[t._v("8.7")]),t._v("版本开始，"),a("code",[t._v("V8")]),t._v("提供了一个非阻塞的方法"),a("code",[t._v("Atomics.waitAsync")]),t._v("，可以用在主线程。")]),t._v(" "),a("p",[t._v("接下来我们将讲解如何实现一个互斥锁（既可以同步用于"),a("code",[t._v("worker")]),t._v("线程，也可以异步用于"),a("code",[t._v("主线程")]),t._v("）")]),t._v(" "),a("p",[a("code",[t._v("Atomics.wait")]),t._v(" 和 "),a("code",[t._v("Atomics.waitAsync")]),t._v(" 接受下列的参数：")]),t._v(" "),a("p",[a("code",[t._v("buffer")]),t._v(": 一个基于 "),a("code",[t._v("SharedArrayBuffer")]),t._v(" 的 "),a("code",[t._v("Int32Array")]),t._v(" 或 "),a("code",[t._v("BigInt64Array")]),t._v("。"),a("br"),t._v(" "),a("code",[t._v("index")]),t._v(": "),a("code",[t._v("buffer")]),t._v("内的一个有效索引值。"),a("br"),t._v(" "),a("code",[t._v("expectedValue")]),t._v(": 我们期望出现在 "),a("code",[t._v("(buffer, index)")]),t._v(" 描述的内存位置上的值。"),a("br"),t._v(" "),a("code",[t._v("timeout")]),t._v(": 以毫秒为单位的超时(可选，默认为 "),a("code",[t._v("Infinity")]),t._v(")。")]),t._v(" "),a("p",[a("code",[t._v("Atomics.wait")]),t._v("的返回值是一个"),a("code",[t._v("string")]),t._v(", 如果指定的内存位置上的值不是"),a("code",[t._v("expectedValue")]),t._v("，"),a("code",[t._v("Atomics.wait")]),t._v("会立即返回"),a("code",[t._v("not-equal")]),t._v(",\n否则，调用该方法的线程会被阻塞，直到另外一个线程在同一个内存位置上调用了"),a("code",[t._v("Atomics.notify")]),t._v("，或者"),a("code",[t._v("timeout")]),t._v("指定的时间到了。\n前一种情况下"),a("code",[t._v("Atomics.wait")]),t._v("的返回值是"),a("code",[t._v("ok")]),t._v(",后一种情况的返回值是"),a("code",[t._v("timed-out")]),t._v("。")]),t._v(" "),a("p",[a("code",[t._v("Atomics.notify")]),t._v(" 接受下列的参数:")]),t._v(" "),a("p",[a("code",[t._v("buffer")]),t._v(": 一个基于 "),a("code",[t._v("SharedArrayBuffer")]),t._v(" 的 "),a("code",[t._v("Int32Array")]),t._v(" 或 "),a("code",[t._v("BigInt64Array")]),t._v(" 。"),a("br"),t._v(" "),a("code",[t._v("index")]),t._v(": "),a("code",[t._v("buffer")]),t._v("内的一个有效索引值。"),a("br"),t._v(" "),a("code",[t._v("count")]),t._v(": 要通知多少等待者("),a("code",[t._v("waiters")]),t._v(")（可选，默认为 "),a("code",[t._v("Infinity")]),t._v("）。")]),t._v(" "),a("p",[t._v("该方法将会以"),a("code",[t._v("FIFO")]),t._v("的顺序通知"),a("code",[t._v("count")]),t._v("个数量的等待者（"),a("code",[t._v("waiters")]),t._v("），"),a("code",[t._v("waiters")]),t._v("在"),a("code",[t._v("(buffer, index)")]),t._v("内存位置上调用了"),a("code",[t._v("wait")]),t._v("等方法。")]),t._v(" "),a("p",[t._v("同一内存位置上调用了"),a("code",[t._v("wait")]),t._v("或"),a("code",[t._v("waitAsync")]),t._v("方法的等待者，都将在同一个"),a("code",[t._v("FIFO")]),t._v("队列中等待唤醒")]),t._v(" "),a("p",[t._v("与"),a("code",[t._v("Atomics.wait")]),t._v("相反，"),a("code",[t._v("Atomics.waitAsync")]),t._v("方法总是立即返回，返回值如下所示：")]),t._v(" "),a("ol",[a("li",[a("code",[t._v("{ async: false, value: 'not-equal' }")]),t._v(" (如果指定的内存位置上不是期待值)")]),t._v(" "),a("li",[a("code",[t._v("{ async: false, value: 'timed-out' }")]),t._v(" (只有当timeout为"),a("code",[t._v("0")]),t._v("时)")]),t._v(" "),a("li",[a("code",[t._v("{ async: true, value: promise }")])])]),t._v(" "),a("p",[t._v("第三种情况下返回的"),a("code",[t._v("promise")]),t._v("将在之后被"),a("code",[t._v("resolve")]),t._v(", "),a("code",[t._v("resolve")]),t._v("的值可能有"),a("code",[t._v("ok")]),t._v("(如果"),a("code",[t._v("Atomics.notify")]),t._v("在同一内存位置上被调用)，"),a("code",[t._v("timed-out")]),t._v("(如果超过了"),a("code",[t._v("timeout")]),t._v("指定的时间)，\n这个promise不会被rejected")]),t._v(" "),a("p",[t._v("下面的例子展示了"),a("code",[t._v("Atomics.waitAsync")]),t._v("的基本用法：")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" sab "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("SharedArrayBuffer")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("16")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" i32a "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Int32Array")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("sab"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" result "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Atomics"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("waitAsync")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("i32a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1000")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//                                     |  |  ^ timeout (opt)")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//                                     |  ^ expected value")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//                                     ^ index")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("result"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("value "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'not-equal'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// The value in the SharedArrayBuffer was not the expected one.")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    result"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("value "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("instanceof")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Promise")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// true")]),t._v("\n    result"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("value"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("then")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("value")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("value "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'ok'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* notified */")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* value is 'timed-out' */")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// In this thread, or in another thread:")]),t._v("\nAtomics"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("notify")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("i32a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("h3",{attrs:{id:"实现一个互斥锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实现一个互斥锁"}},[t._v("#")]),t._v(" 实现一个互斥锁")]),t._v(" "),a("p",[t._v("接下来，我们将讨论如何实现一个既可以同步又可以异步的互斥锁。\n我们不会使用"),a("code",[t._v("timeout")]),t._v("这个参数，这个参数可以在实现条件变量（"),a("code",[t._v("condition variables")]),t._v("）的时候再使用。")]),t._v(" "),a("p",[t._v("互斥锁通过操作"),a("code",[t._v("SharedArrayBuffer")]),t._v("实现了下面三个方法：")]),t._v(" "),a("ol",[a("li",[t._v("lock — 阻塞线程，直到我们能够获得互斥锁（只能在"),a("code",[t._v("worker")]),t._v("线程上使用）")]),t._v(" "),a("li",[t._v("unlock — 释放互斥锁")]),t._v(" "),a("li",[t._v("executeLocked(callback) — 非阻塞锁，可供主线程使用，在获得锁后执行回调函数")])]),t._v(" "),a("p",[t._v("具体实现如下，构造函数接收一个"),a("code",[t._v("SharedArrayBuffer")]),t._v(", 并初始化一个"),a("code",[t._v("Int32Array")]),t._v("。")]),t._v(" "),a("div",{staticClass:"language-typescript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-typescript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AsyncLock")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("INDEX")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("UNLOCKED")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("LOCKED")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    \n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("constructor")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("sab"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" SharedArrayBuffer"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("sab "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" sab"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("i32a "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Int32Array")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("sab"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    \n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("lock")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* … */")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    \n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("unlock")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* … */")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    \n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("executeLocked")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("f"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* … */")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("i32a[0]的值要么是"),a("code",[t._v("LOCKED")]),t._v("， 要么是"),a("code",[t._v("UNLOCKED")]),t._v("。它也会被用于指定"),a("code",[t._v("Atomics.wait")]),t._v(" 和 "),a("code",[t._v("Atomics.waitAsync")]),t._v("方法去"),a("code",[t._v("wait")]),t._v("的内存位置。")]),t._v(" "),a("p",[t._v("互斥锁需要保证下列的不变性关系:"),a("br"),t._v("\n如果i32a[0] == LOCKED，并且有一个线程在等待（无论是通过"),a("code",[t._v("Atomics.wait")]),t._v("还是"),a("code",[t._v("Atomics.waitAsync")]),t._v("）i32a[0]上指定的值，它最终"),a("strong",[t._v("必须")]),t._v("要收到通知（"),a("code",[t._v("be notified")]),t._v("）。"),a("br"),t._v("\n在收到通知后，线程将会尝试获取锁。如果成功获取到锁，它"),a("strong",[t._v("必须")]),t._v("在释放锁后再次发出通知。")]),t._v(" "),a("h3",{attrs:{id:"同步上锁和解锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#同步上锁和解锁"}},[t._v("#")]),t._v(" 同步上锁和解锁")]),t._v(" "),a("p",[t._v("接下来展示的是可以在"),a("code",[t._v("worker")]),t._v("线程中调用的阻塞性锁")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("lock")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" oldValue "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Atomics"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("compareExchange")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("i32a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" AsyncLock"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("INDEX")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                                    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* old value >>> */")]),t._v("  AsyncLock"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("UNLOCKED")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                                    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* new value >>> */")]),t._v("  AsyncLock"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("LOCKED")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("oldValue "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" AsyncLock"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("UNLOCKED")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        Atomics"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("wait")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("i32a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" AsyncLock"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("INDEX")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                        AsyncLock"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("LOCKED")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// <<< expected value at start")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("当一个线程调用"),a("code",[t._v("lock()")]),t._v("时，它首先尝试通过使用"),a("code",[t._v("Atomics.compareExchange")]),t._v("将锁状态从"),a("code",[t._v("UNLOCKED")]),t._v("更改为"),a("code",[t._v("LOCKED")]),t._v("来获取锁。")]),t._v(" "),a("p",[a("code",[t._v("Atomics.compareExchange")]),t._v(" 会尝试以原子操作的形式("),a("code",[t._v("atomically")]),t._v(")进行状态更改，并返回指定内存位置上的原始值。\n如果原始值是 "),a("code",[t._v("UNLOCKED")]),t._v("，我们就知道状态改变成功，并且该线程成功获得了锁。其他就不需要再做什么了。")]),t._v(" "),a("p",[t._v("如果"),a("code",[t._v("Atomics.compareExchange")]),t._v("无法更改锁状态，则必然有另一个线程正在持有锁。\n因此，该线程使用"),a("code",[t._v("Atomics.wait")]),t._v("以等待另一个线程释放锁。")]),t._v(" "),a("p",[t._v("如果内存位置上仍是预期值（在本例中为 "),a("code",[t._v("AsyncLock.LOCKED")]),t._v("），则 "),a("code",[t._v("Atomics.wait")]),t._v(" 方法将会阻塞该线程，\n并且仅当另一个线程调用 "),a("code",[t._v("Atomics.notify")]),t._v(" 时，"),a("code",[t._v("Atomics.wait")]),t._v(" 调用才会返回。")]),t._v(" "),a("p",[a("code",[t._v("unlock")]),t._v("方法则是将锁设置为 "),a("code",[t._v("UNLOCKED")]),t._v(" 状态并调用 "),a("code",[t._v("Atomics.notify")]),t._v(" 唤醒一个正在等待锁的等待者("),a("code",[t._v("waiter")]),t._v(")。\n这样的状态更改不应该失败，因为调用这个方法的线程必然持有锁，同时其他人不能也不应该调用 "),a("code",[t._v("unlock()")]),t._v("。")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("unlock")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" oldValue "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Atomics"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("compareExchange")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("i32a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" AsyncLock"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("INDEX")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* old value >>> */")]),t._v("  AsyncLock"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("LOCKED")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* new value >>> */")]),t._v("  AsyncLock"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("UNLOCKED")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("oldValue "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" AsyncLock"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("LOCKED")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("throw")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Error")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Tried to unlock while not holding the mutex'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    Atomics"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("notify")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("i32a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" AsyncLock"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("INDEX")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("大部分情况下应该是这样的："),a("br"),t._v("\n锁是空闲的，线程 "),a("code",[t._v("T1")]),t._v(" 通过使用 "),a("code",[t._v("Atomics.compareExchange")]),t._v(" 更改锁状态来获取它。线程 "),a("code",[t._v("T2")]),t._v(" 尝试通过调用 "),a("code",[t._v("Atomics.compareExchange")]),t._v(" 来获取锁，但没有成功。然后"),a("code",[t._v("T2")]),t._v("调用 "),a("code",[t._v("Atomics.wait")]),t._v("，它会阻塞"),a("code",[t._v("T2")]),t._v("线程。")]),t._v(" "),a("p",[t._v("在之后的某个时刻，"),a("code",[t._v("T1")]),t._v(" 释放锁并调用 "),a("code",[t._v("Atomics.notify")]),t._v("。这使得 "),a("code",[t._v("T2")]),t._v(" 中的 "),a("code",[t._v("Atomics.wait")]),t._v(" 调用返回"),a("code",[t._v("ok")]),t._v("，唤醒了 "),a("code",[t._v("T2")]),t._v("线程。然后 "),a("code",[t._v("T2")]),t._v(" 再次尝试获取锁，这次成功了。")]),t._v(" "),a("p",[t._v("此外还有2种可能的极端情况:")]),t._v(" "),a("p",[t._v("情况1. "),a("code",[t._v("T1")]),t._v(" 持有锁，"),a("code",[t._v("T2")]),t._v(" 尝试获取它。首先，"),a("code",[t._v("T2")]),t._v(" 尝试使用 "),a("code",[t._v("Atomics.compareExchange")]),t._v(" 更改锁定状态，但没有成功。\n但随后 "),a("code",[t._v("T1")]),t._v(" 在 "),a("code",[t._v("T2")]),t._v(" 调用 "),a("code",[t._v("Atomics.wait")]),t._v(" 之前就释放了锁。当 "),a("code",[t._v("T2")]),t._v(" 调用 "),a("code",[t._v("Atomics.wait")]),t._v(" 时，它会立即返回值 "),a("code",[t._v("not-equal")]),t._v("。在这种情况下，"),a("code",[t._v("T2")]),t._v(" 将继续下一次循环迭代，尝试再次获取锁。")]),t._v(" "),a("p",[t._v("情况2. "),a("code",[t._v("T1")]),t._v(" 持有锁，"),a("code",[t._v("T2")]),t._v(" 使用 "),a("code",[t._v("Atomics.wait")]),t._v(" 等待它。 "),a("code",[t._v("T1")]),t._v("释放锁 —— "),a("code",[t._v("T2")]),t._v(" 被唤醒（"),a("code",[t._v("Atomics.wait")]),t._v(" 调用返回）并尝试执行 "),a("code",[t._v("Atomics.compareExchange")]),t._v(" 以获取锁，\n但另一个线程 "),a("code",[t._v("T3")]),t._v(" 在"),a("code",[t._v("T2")]),t._v("之前就已经获取了锁（可能是运行更快等原因）。因此"),a("code",[t._v("T2")]),t._v("对 "),a("code",[t._v("Atomics.compareExchange")]),t._v(" 的调用未能获得锁，"),a("code",[t._v("T2")]),t._v(" 再次调用 "),a("code",[t._v("Atomics.wait")]),t._v("，阻塞直到 "),a("code",[t._v("T3")]),t._v(" 释放锁。")]),t._v(" "),a("p",[t._v("由于后一种情况，互斥锁并不“公平”，有可能 "),a("code",[t._v("T2")]),t._v(" 一直在等待释放锁，但 "),a("code",[t._v("T3")]),t._v(" 来了就马上拿到了锁。一个在实现上更好的锁可能会使用多种状态来区分“锁定”和“竞争锁定”。")]),t._v(" "),a("h3",{attrs:{id:"异步上锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异步上锁"}},[t._v("#")]),t._v(" 异步上锁")]),t._v(" "),a("p",[t._v("与阻塞性的"),a("code",[t._v("lock")]),t._v("等方法不同的是，非阻塞性的"),a("code",[t._v("executeLocked")]),t._v("方法可以被主线程调用。它获取一个回调函数作为其唯一参数，并在成功获取锁后执行回调函数。")]),t._v(" "),a("div",{staticClass:"language-javascript extra-class"},[a("pre",{pre:!0,attrs:{class:"language-javascript"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("executeLocked")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("f")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" self "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    \n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("async")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("tryGetLock")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" oldValue "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Atomics"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("compareExchange")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("self"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("i32a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" AsyncLock"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("INDEX")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                                        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* old value >>> */")]),t._v("  AsyncLock"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("UNLOCKED")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                                        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* new value >>> */")]),t._v("  AsyncLock"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("LOCKED")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("oldValue "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" AsyncLock"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("UNLOCKED")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("f")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n                self"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("unlock")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n                "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" result "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Atomics"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("waitAsync")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("self"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("i32a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" AsyncLock"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("INDEX")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                                                        AsyncLock"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("LOCKED")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n                                                        "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//  ^ expected value at start")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("await")]),t._v(" result"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("value"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    \n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("tryGetLock")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("内部函数 "),a("code",[t._v("tryGetLock")]),t._v(" 先尝试使用 "),a("code",[t._v("Atomics.compareExchange")]),t._v(" 获取锁。 如果成功改变了锁状态，它将执行回调，释放锁，然后返回。")]),t._v(" "),a("p",[t._v("如果 "),a("code",[t._v("Atomics.compareExchange")]),t._v(" 获取锁失败，我们需要在锁可能空闲时重试。\n我们不能阻塞并等待锁释放 —— 相反，我们使用 "),a("code",[t._v("Atomics.waitAsync")]),t._v(" 和它返回的 "),a("code",[t._v("Promise")]),t._v(" 来进行新的尝试。")]),t._v(" "),a("p",[t._v("如果我们调用了 "),a("code",[t._v("Atomics.waitAsync")]),t._v("，当持有锁的线程执行 "),a("code",[t._v("Atomics.notify")]),t._v(" 时，返回的 "),a("code",[t._v("Promise")]),t._v(" 将会被resolve。 然后等待锁的线程尝试再次获取锁，就像以前一样。")]),t._v(" "),a("p",[t._v("同样的极端情况（在 "),a("code",[t._v("Atomics.compareExchange")]),t._v(" 调用和 "),a("code",[t._v("Atomics.waitAsync")]),t._v(" 调用之间释放锁，以及在 "),a("code",[t._v("Promise")]),t._v(" resolve 和 "),a("code",[t._v("Atomics.compareExchange")]),t._v("调用之间再次获取锁）在这里也是存在的，\n所以，代码必须以稳健("),a("code",[t._v("robust")]),t._v(")的方式处理它们。")])])}),[],!1,null,null,null);s.default=e.exports}}]);