import{_ as A,c as C,a as l,b as s,e as n,w as a,d as o,r as y,o as u}from"./app.fd297097.js";const ys=JSON.parse('{"title":"146. LRU缓存","description":"","frontmatter":{"title":"146. LRU缓存"},"headers":[],"relativePath":"algorithm/leetcode/lru.md","lastUpdated":1633355423000}'),m={name:"algorithm/leetcode/lru.md"},_=l("div",{class:"tip custom-block"},[l("p",{class:"custom-block-title"},"原题链接"),l("p",null,[l("a",{href:"https://leetcode-cn.com/problems/lru-cache/",target:"_blank",rel:"noreferrer"},"LeetCode 146")])],-1),d=l("p",null,"LRU 缓存机制可以通过哈希表辅以双向链表实现，我们用一个哈希表和一个双向链表维护所有在缓存中的键值对。",-1),h=l("ul",null,[l("li",null,[l("p",null,"双向链表按照被使用的顺序存储了这些键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。")]),l("li",null,[l("p",null,"哈希表即为普通的哈希映射（HashMap），通过缓存数据的键映射到其在双向链表中的位置。")])],-1),b={class:"katex"},f={class:"katex-mathml"},T=o("",1),g=l("code",null,"get",-1),x=l("code",null,"put",-1),B=l("p",null,[s("对于 "),l("code",null,"get"),s(" 操作，首先判断 "),l("code",null,"key"),s(" 是否存在：")],-1),k=l("code",null,"key",-1),v={class:"katex"},w={class:"katex-mathml"},L=o("",1),S=l("li",null,[l("p",null,[s("如果 "),l("code",null,"key"),s(" 存在，则 "),l("code",null,"key"),s(" 对应的节点是最近被使用的节点。通过哈希表定位到该节点在双向链表中的位置，并将其移动到双向链表的头部，最后返回该节点的值。")])],-1),N=o("",1),M={class:"katex"},V={class:"katex-mathml"},E=o("",1),I={class:"katex"},P={class:"katex-mathml"},O=o("",1),H={class:"katex"},R={class:"katex-mathml"},U=o("",1),$=l("div",{class:"tip custom-block"},[l("p",{class:"custom-block-title"},"TIP"),l("p",null,[s("在双向链表的实现中，使用一个"),l("strong",null,"伪头部"),s("（dummy head）和"),l("strong",null,"伪尾部"),s("（dummy tail）标记界限， 这样在添加节点和删除节点的时候就不需要检查相邻的节点是否存在。")])],-1),J=l("p",null,[l("strong",null,"复杂度分析")],-1),j=l("code",null,"put",-1),q=l("code",null,"get",-1),z={class:"katex"},G={class:"katex-mathml"},K=o("",1),Q={class:"katex"},W={class:"katex-mathml"},X=o("",1),Y={class:"katex"},Z={class:"katex-mathml"},ss=o("",1),ns=o("",1);function as(ls,ps,os,es,ts,cs){const D=y("mi"),p=y("mo"),F=y("mn"),e=y("mrow"),t=y("annotation"),c=y("semantics"),r=y("math"),i=y("mtext");return u(),C("div",null,[_,d,h,l("p",null,[s("这样以来，我们首先使用哈希表进行定位，找出缓存项在双向链表中的位置，随后将其移动到双向链表的头部，即可在 "),l("span",b,[l("span",f,[n(r,{xmlns:"http://www.w3.org/1998/Math/MathML"},{default:a(()=>[n(c,null,{default:a(()=>[n(e,null,{default:a(()=>[n(D,null,{default:a(()=>[s("O")]),_:1}),n(p,{stretchy:"false"},{default:a(()=>[s("(")]),_:1}),n(F,null,{default:a(()=>[s("1")]),_:1}),n(p,{stretchy:"false"},{default:a(()=>[s(")")]),_:1})]),_:1}),n(t,{encoding:"application/x-tex"},{default:a(()=>[s("O(1)")]),_:1})]),_:1})]),_:1})]),T]),s(" 的时间内完成 "),g,s(" 或者 "),x,s(" 操作。具体的方法如下：")]),l("ul",null,[l("li",null,[B,l("ul",null,[l("li",null,[l("p",null,[s("如果 "),k,s(" 不存在，则返回 "),l("span",v,[l("span",w,[n(r,{xmlns:"http://www.w3.org/1998/Math/MathML"},{default:a(()=>[n(c,null,{default:a(()=>[n(e,null,{default:a(()=>[n(p,null,{default:a(()=>[s("−")]),_:1}),n(F,null,{default:a(()=>[s("1")]),_:1})]),_:1}),n(t,{encoding:"application/x-tex"},{default:a(()=>[s("-1")]),_:1})]),_:1})]),_:1})]),L]),s("；")])]),S])]),N]),l("p",null,[s("上述各项操作中，访问哈希表的时间复杂度为 "),l("span",M,[l("span",V,[n(r,{xmlns:"http://www.w3.org/1998/Math/MathML"},{default:a(()=>[n(c,null,{default:a(()=>[n(e,null,{default:a(()=>[n(D,null,{default:a(()=>[s("O")]),_:1}),n(p,{stretchy:"false"},{default:a(()=>[s("(")]),_:1}),n(F,null,{default:a(()=>[s("1")]),_:1}),n(p,{stretchy:"false"},{default:a(()=>[s(")")]),_:1})]),_:1}),n(t,{encoding:"application/x-tex"},{default:a(()=>[s("O(1)")]),_:1})]),_:1})]),_:1})]),E]),s("，在双向链表的头部添加节点、在双向链表的尾部删除节点的复杂度也为 "),l("span",I,[l("span",P,[n(r,{xmlns:"http://www.w3.org/1998/Math/MathML"},{default:a(()=>[n(c,null,{default:a(()=>[n(e,null,{default:a(()=>[n(D,null,{default:a(()=>[s("O")]),_:1}),n(p,{stretchy:"false"},{default:a(()=>[s("(")]),_:1}),n(F,null,{default:a(()=>[s("1")]),_:1}),n(p,{stretchy:"false"},{default:a(()=>[s(")")]),_:1})]),_:1}),n(t,{encoding:"application/x-tex"},{default:a(()=>[s("O(1)")]),_:1})]),_:1})]),_:1})]),O]),s("。而将一个节点移到双向链表的头部，可以分成「删除该节点」和「在双向链表的头部添加节点」两步操作，都可以在 "),l("span",H,[l("span",R,[n(r,{xmlns:"http://www.w3.org/1998/Math/MathML"},{default:a(()=>[n(c,null,{default:a(()=>[n(e,null,{default:a(()=>[n(D,null,{default:a(()=>[s("O")]),_:1}),n(p,{stretchy:"false"},{default:a(()=>[s("(")]),_:1}),n(F,null,{default:a(()=>[s("1")]),_:1}),n(p,{stretchy:"false"},{default:a(()=>[s(")")]),_:1})]),_:1}),n(t,{encoding:"application/x-tex"},{default:a(()=>[s("O(1)")]),_:1})]),_:1})]),_:1})]),U]),s(" 时间内完成。")]),$,J,l("ul",null,[l("li",null,[l("p",null,[s("时间复杂度：对于 "),j,s(" 和 "),q,s(" 都是 "),l("span",z,[l("span",G,[n(r,{xmlns:"http://www.w3.org/1998/Math/MathML"},{default:a(()=>[n(c,null,{default:a(()=>[n(e,null,{default:a(()=>[n(D,null,{default:a(()=>[s("O")]),_:1}),n(p,{stretchy:"false"},{default:a(()=>[s("(")]),_:1}),n(F,null,{default:a(()=>[s("1")]),_:1}),n(p,{stretchy:"false"},{default:a(()=>[s(")")]),_:1})]),_:1}),n(t,{encoding:"application/x-tex"},{default:a(()=>[s("O(1)")]),_:1})]),_:1})]),_:1})]),K]),s("。")])]),l("li",null,[l("p",null,[s("空间复杂度："),l("span",Q,[l("span",W,[n(r,{xmlns:"http://www.w3.org/1998/Math/MathML"},{default:a(()=>[n(c,null,{default:a(()=>[n(e,null,{default:a(()=>[n(D,null,{default:a(()=>[s("O")]),_:1}),n(p,{stretchy:"false"},{default:a(()=>[s("(")]),_:1}),n(i,null,{default:a(()=>[s("capacity")]),_:1}),n(p,{stretchy:"false"},{default:a(()=>[s(")")]),_:1})]),_:1}),n(t,{encoding:"application/x-tex"},{default:a(()=>[s("O(\\text{capacity})")]),_:1})]),_:1})]),_:1})]),X]),s("，因为哈希表和双向链表最多存储 "),l("span",Y,[l("span",Z,[n(r,{xmlns:"http://www.w3.org/1998/Math/MathML"},{default:a(()=>[n(c,null,{default:a(()=>[n(e,null,{default:a(()=>[n(i,null,{default:a(()=>[s("capacity")]),_:1}),n(p,null,{default:a(()=>[s("+")]),_:1}),n(F,null,{default:a(()=>[s("1")]),_:1})]),_:1}),n(t,{encoding:"application/x-tex"},{default:a(()=>[s("\\text{capacity} + 1")]),_:1})]),_:1})]),_:1})]),ss]),s(" 个元素。")])])]),ns])}const Fs=A(m,[["render",as]]);export{ys as __pageData,Fs as default};
